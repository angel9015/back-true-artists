class ConversationService
  attr_reader :params

  def initialize(params = {})
    @params = params
  end

  def call
    return OpenStruct.new({ success?: true, payload: conversation }) if conversation

    # Do not create a conversation without a valid recipient or sender
    return find_sender unless find_sender.success?
    return find_recipient unless find_recipient.success?

    conversation = Conversation.new(
      sender_id: find_sender.payload.id,
      receiver_id: find_recipient.payload.id
    )
    if conversation.save
      OpenStruct.new({ success?: true, payload: conversation })
    else
      OpenStruct.new({ success?: false, errors: conversation.errors.full_messages })
    end
  end

  def conversation
    @conversation ||= Conversation.between(find_sender.payload.id, find_recipient.payload.id).first
  end

  def find_sender
    user ||= User.find_by(id: params[:sender_id]) || User.find_by(email: params[:email])
    return OpenStruct.new({ success?: true, payload: user }) if user

    user_service = UserService.new(
      params.slice(:email, :full_name, :autogenerated)
    ).call

    if user_service.success?
      OpenStruct.new({ success?: true, payload: user_service.payload })
    else
      OpenStruct.new({ success?: false, errors: user_service.errors.full_messages })
    end
  end

  def find_recipient
    user ||= User.find_by(id: params[:receiver_id])
    return OpenStruct.new({ success?: true, payload: user }) if user

    unless params[:recipient_type] && params[:recipient_id]
      return OpenStruct.new({ success?: false, payload: ['Select a valid artist or studio'] })
    end

    #TODO make it possible to search by slug or id
    recipient_object = params[:recipient_type].constantize.find_by(slug: params[:recipient_id])

    if recipient_object&.user
      OpenStruct.new({ success?: true, payload: recipient_object.user })
    else
      OpenStruct.new({ success?: false, errors: ['We could not send a message to this recipient'] })
    end
  end
end
