# frozen_string_literal: true

class User < ApplicationRecord
  include IdentityCache
  enum status: {
    active: 'active',
    inactive: 'inactive',
    suspended: 'suspended',
    closed: 'closed'
  }

  searchkick locations: [:location],
             searchable: %i[full_name email status role],
             filterable: %i[status role]

  enum role: {
    admin: 'admin',
    artist: 'artist',
    studio_manager: 'studio_manager',
    regular: 'regular'
  }

  require 'json_web_token'
  extend FriendlyId
  friendly_id :slug_candidates, use: %i[slugged finders]

  acts_as_favoritor
  before_save :downcase_email
  has_secure_password

  has_one :artist, dependent: :destroy
  has_one :studio, dependent: :destroy
  has_many :articles, dependent: :destroy
  has_many :conventions, class_name: 'Convention', foreign_key: 'created_by', dependent: :destroy
  has_many :announcements, class_name: 'Announcement', foreign_key: 'published_by', dependent: :destroy

  scope :artists, -> { where(role: roles[:artist]) }
  scope :studios, -> { where(role: roles[:studio_manager]) }
  scope :admins, -> { where(role:  roles[:admin]) }

  STRONG_PASSWORD = /(?=.*[a-zA-Z])(?=.*[0-9]).{6,10}/.freeze

  validates :role, presence: true
  validates :password, presence: true, format: { with: STRONG_PASSWORD }, on: :create
  validates :password_confirmation, presence: true, on: :create
  validates :email, presence: true, uniqueness: { case_sensitive: false },
                    format: { with: URI::MailTo::EMAIL_REGEXP }
  validates_confirmation_of :password_confirmation,
                            message: 'password does match confirmation',
                            on: :create

  after_initialize :assign_basic_role, if: :new_record?
  after_commit :change_password_request, on: :create, if: :autogenerated?

  def slug_candidates
    [
      :full_name,
      %i[full_name id]
    ]
  end

  def assign_basic_role
    self.role = User.roles[:regular]
    self.status = User.statuses[:active]
  end

  def downcase_email
    self.email = email.strip.downcase
  end

  def reset_password_request
    UserMailer.password_reset_instructions(self, auth_token).deliver_now
  end

  def auth_token
    JsonWebToken.encode(user_id: id)
  end

  def set_new_password(attrs)
    return unless attrs[:password] == attrs[:password_confirmation]

    update(password: attrs[:password])
  end

  def notify_on_password_update
    UserMailer.notify_on_password_update(self, auth_token).deliver_now
  end

  def assign_role(role)
    update(role: User.roles[role.to_sym])
  end

  def admin?
    role == User.roles[:admin]
  end
  
  def role_is?(assigned_role)
    assigned_role == role
  end

  def change_password_request
    UserMailer.change_password_request(self, password).deliver_now
  end

  def self.find_by_password_reset_token(token)
    jwt_payload = JsonWebToken.decode(token).first
    find(jwt_payload['user_id'])
  rescue JWT::ExpiredSignature, JWT::VerificationError, JWT::DecodeError
    nil
  end
end
